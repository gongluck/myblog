---
title: "基础组件开发专栏"
date: 2020-11-30T20:58:32+08:00
draft: false

featured_image: "img/linux_wh.jpg"
categories: linux
tags: [linux]
---

## 三、基础组件开发专栏

### 0.项目仓库

- [https://github.com/gongluck/CVIP.git](https://github.com/gongluck/CVIP.git)

### 1.线程池原理与实现

#### 1.1 线程池工作流程

![线程池工作流程](https://github.com/gongluck/CVIP/blob/master/images/线程池工作流程.png)

#### 1.2 线程池实现

- [线程池实现代码](https://github.com/gongluck/CVIP/blob/master/code/threadpool/threadpool.c)

  <details>
  <summary>线程池实现代码</summary>
  
  ```C
  #include <pthread.h>
  
  // 添加队列节点
  #define LL_ADD(item, list) \
      do                     \
      {                      \
          item->prev = NULL; \
          item->next = list; \
          list = item;       \
      } while (0)
  
  // 移除队列节点
  #define LL_REMOVE(item, list)              \
      do                                     \
      {                                      \
          if (item->prev != NULL)            \
              item->prev->next = item->next; \
          if (item->next != NULL)            \
              item->next->prev = item->prev; \
          if (list == item)                  \
              list = item->next;             \
          item->prev = item->next = NULL;    \
      } while (0)
  
  // 工作线程
  typedef struct WORKER
  {
      pthread_t thread;
      int terminate;
      struct WORKQUEUE *workqueue;
      struct WORKER *prev;
      struct WORKER *next;
  } Worker;
  
  // 工作任务
  typedef struct JOB
  {
      void (*job_function)(struct JOB *job);
      void *user_data;
      struct JOB *prev;
      struct JOB *next;
  } Job;
  
  // 工作调度
  typedef struct WORKQUEUE
  {
      struct WORKER *workers;
      struct JOB *waiting_jobs;
      pthread_mutex_t jobs_mtx;
      pthread_cond_t jobs_cond;
  } WorkQueue;
  
  typedef WorkQueue ThreadPool;
  
  // 工作线程回调函数
  static void *WorkerThread(void *ptr)
  {
      Worker *worker = (Worker *)ptr;
  
      while (1)
      {
          pthread_mutex_lock(&worker->workqueue->jobs_mtx);
  
          while (worker->workqueue->waiting_jobs == NULL)
          {
              if (worker->terminate)
                  break;
              pthread_cond_wait(&worker->workqueue->jobs_cond, &worker->workqueue->jobs_mtx);
          }
  
          if (worker->terminate)
          {
              pthread_mutex_unlock(&worker->workqueue->jobs_mtx);
              break;
          }
  
          Job *job = worker->workqueue->waiting_jobs;
          if (job != NULL)
          {
              LL_REMOVE(job, worker->workqueue->waiting_jobs);
          }
  
          pthread_mutex_unlock(&worker->workqueue->jobs_mtx);
  
          if (job == NULL)
              continue;
  
          job->job_function(job);
      }
  
      free(worker);
      pthread_exit(NULL);
  }
  
  // 创建线程池
  int ThreadPoolCreate(ThreadPool *workqueue, int numWorkers)
  {
      if (numWorkers < 1)
          numWorkers = 1;
      memset(workqueue, 0, sizeof(ThreadPool));
  
      pthread_mutex_init(&workqueue->jobs_mtx, NULL);
      pthread_cond_init(&workqueue->jobs_cond, NULL);
  
      for (int i = 0; i < numWorkers; i++)
      {
          Worker *worker = (Worker *)malloc(sizeof(Worker));
          if (worker == NULL)
          {
              perror("malloc");
              return 1;
          }
  
          memset(worker, 0, sizeof(Worker));
          worker->workqueue = workqueue;
  
          int ret = pthread_create(&worker->thread, NULL, WorkerThread, (void *)worker);
          if (ret)
          {
              perror("pthread_create");
              free(worker);
              return 1;
          }
  
          LL_ADD(worker, worker->workqueue->workers);
      }
  
      return 0;
  }
  
  // 终止线程池
  void ThreadPoolShutdown(ThreadPool *workqueue)
  {
      for (Worker *worker = workqueue->workers; worker != NULL; worker = worker->next)
      {
          worker->terminate = 1;
      }
  
      pthread_mutex_lock(&workqueue->jobs_mtx);
  
      workqueue->workers = NULL;
      workqueue->waiting_jobs = NULL;
  
      pthread_cond_broadcast(&workqueue->jobs_cond);
  
      pthread_mutex_unlock(&workqueue->jobs_mtx);
  }
  
  // 添加任务
  void ThreadPoolQueue(ThreadPool *workqueue, Job *job)
  {
      pthread_mutex_lock(&workqueue->jobs_mtx);
  
      LL_ADD(job, workqueue->waiting_jobs);
  
      pthread_cond_signal(&workqueue->jobs_cond);
      pthread_mutex_unlock(&workqueue->jobs_mtx);
  }
  ```
  </details>

### 2.CAS和无锁队列

#### 2.1 CAS

- 比较并交换（compare and swap，CAS），是**原⼦操作**的⼀种，可⽤于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某⼀数据时由于执行顺序不确定性以及中断的不可预知性产⽣的数据不一致问题有了CAS，我们就可以用它来实现各种无锁（lock free）的数据结构。

- 该操作通过将内存中的值与指定数据进行比较，当数值⼀样时将内存中的数据替换为新的值。

  ```C
  int compare_and_swap(int *reg, int oldval, int newval)
  {
      int old_ref_val = *reg;
      if(old_reg_val == oldval)//compare
          *reg = newval;//swap
      return old_reg_val;
  }
  ```

- gcc/g++中的CAS

  ```C
  bool __sync_bool_compare_and_swap(type *ptr, type oldval type newval, ...);
  type __sync_val_compare_and_swap(type *ptr, type oldval type newval, ...);
  ```

- Windows的CAS

  ```C
  InterlockedCompareExchange(__inout LONG volatile  *Target, __in LONG Exchange, __in LONG Comperand);
  ```

- C++11标准库的CAS

  ```C
  template< class T >
  bool atomic_compare_exchange_weak(std::atomic<T>* obj, T* expected, T desired);
  template< class T >
  bool atomic_compare_exchange_weak(volatile std::atomic<T>* obj, T* expected, T desired );
  ```

#### 2.2 无锁队列

- [无锁队列代码](https://github.com/gongluck/CVIP/blob/master/code/cas/cas.h)

  <details>
  <summary>无锁队列代码</summary>
  
  ```C
  /*
   * @Author: gongluck 
   * @Date: 2020-11-16 16:02:56 
   * @Last Modified by:   gongluck 
   * @Last Modified time: 2020-11-16 16:02:56 
   */
  
  template <typename ElemType>
  class Queue
  {
  public:
      Queue();
      ~Queue();
  
  public:
      void push(ElemType elem);
      bool pop();
      void show();
  
  private:
      struct _qNode
      {
          _qNode() : _next(nullptr) {}
          _qNode(ElemType elem) : _elem(elem), _next(nullptr) {}
          ElemType _elem;
          struct _qNode *_next;
      };
  
  private:
      struct _qNode *_head;
      struct _qNode *_tail;
  };
  
  template <typename ElemType>
  Queue<ElemType>::Queue()
  {
      _head = _tail = new _qNode();
  }
  
  template <typename ElemType>
  Queue<ElemType>::~Queue()
  {
      while (_head != nullptr)
      {
          struct _qNode *tempNode = _head;
          _head = _head->_next;
          delete tempNode;
      }
  }
  
  template <typename ElemType>
  void Queue<ElemType>::push(ElemType elem)
  {
      struct _qNode *newNode = new struct _qNode(elem);
      struct _qNode *oldp = _tail;
      while (!__sync_bool_compare_and_swap(&_tail->_next, nullptr, newNode))
          ;
      __sync_bool_compare_and_swap(&_tail, oldp, newNode);
  }
  
  template <typename ElemType>
  bool Queue<ElemType>::pop()
  {
      struct _qNode *p;
      do
      {
          p = _head;
          if (p->_next == nullptr)
              return false;
      } while (!__sync_bool_compare_and_swap(&_head, p, p->_next));
      delete p;
      return true;
  }
  ```
  </details>
  

### 3.内存池

#### 3.1 Nginx内存池结构

- Nginx内存池结构

  ![Nginx内存池结构](https://github.com/gongluck/CVIP/blob/master/images/Nginx内存池结构.jpg)

- nginx对内存的管理分为大内存与小内存，当某一个申请的内存大于某一个值时，就需要从大内存中分配空间，否则从小内存中分配空间。

- nginx中的内存池是在创建的时候就设定好了大小，在以后分配小块内存的时候，如果内存不够，则是重新创建一块内存串到内存池中，而不是将原有的内存池进行扩张。当要分配大块内存是，则是在内存池外面再分配空间进行管理的，称为大块内存池。

- Nginx内存池中大内存块和小内存块的分配与释放是不一样的。使用内存池时，可以使用ngx_palloc进行分配，使用ngx_pfree释放。对于大内存，这样做是没有问题的，而对于小内存就不一样了，分配的小内存，不会进行释放。

#### 3.2 [Nginx内存池的实现](https://github.com/gongluck/CVIP/blob/master/code/mmpool/ngx_palloc.c)

<details>
<summary>Nginx内存池的实现</summary>


```C
ngx_pool_t *
ngx_create_pool(size_t size, ngx_log_t *log)
{
    ngx_pool_t  *p;

    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);
    if (p == NULL) {
        return NULL;
    }

    p->d.last = (u_char *) p + sizeof(ngx_pool_t);//初始状态：last指向ngx_pool_t结构体之后数据取起始位置
    p->d.end = (u_char *) p + size;//end指向分配的整个size大小的内存的末尾
    p->d.next = NULL;
    p->d.failed = 0;

    size = size - sizeof(ngx_pool_t);
    p->max = (size < NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;

    p->current = p;
    p->chain = NULL;
    p->large = NULL;
    p->cleanup = NULL;
    p->log = log;

    return p;
}


void
ngx_destroy_pool(ngx_pool_t *pool)
{
    ngx_pool_t          *p, *n;
    ngx_pool_large_t    *l;
    ngx_pool_cleanup_t  *c;

    //首先调用所有的数据清理函数
    for (c = pool->cleanup; c; c = c->next) {
        if (c->handler) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                           "run cleanup: %p", c);
            c->handler(c->data);
        }
    }

#if (NGX_DEBUG)

    /*
     * we could allocate the pool->log from this pool
     * so we cannot use this log while free()ing the pool
     */

    for (l = pool->large; l; l = l->next) {
        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0, "free: %p", l->alloc);
    }

    for (p = pool, n = pool->d.next; /* void */; p = n, n = n->d.next) {
        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                       "free: %p, unused: %uz", p, p->d.end - p->d.last);

        if (n == NULL) {
            break;
        }
    }

#endif

    //释放所有的大块内存
    for (l = pool->large; l; l = l->next) {
        if (l->alloc) {
            ngx_free(l->alloc);
        }
    }

    //最后释放所有内存池中的内存块
    for (p = pool, n = pool->d.next; /* void */; p = n, n = n->d.next) {
        ngx_free(p);

        if (n == NULL) {
            break;
        }
    }
}


void
ngx_reset_pool(ngx_pool_t *pool)
{
    ngx_pool_t        *p;
    ngx_pool_large_t  *l;

    //释放所有大块内存
    for (l = pool->large; l; l = l->next) {
        if (l->alloc) {
            ngx_free(l->alloc);
        }
    }

    //重置所有小块内存区
    for (p = pool; p; p = p->d.next) {
        p->d.last = (u_char *) p + sizeof(ngx_pool_t);
        p->d.failed = 0;
    }

    pool->current = pool;
    pool->chain = NULL;
    pool->large = NULL;
}


void *
ngx_palloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size <= pool->max) {
        return ngx_palloc_small(pool, size, 1);
    }
#endif

    return ngx_palloc_large(pool, size);
}


void *
ngx_pnalloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size <= pool->max) {
        return ngx_palloc_small(pool, size, 0);
    }
#endif

    return ngx_palloc_large(pool, size);
}


static ngx_inline void *
ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)
{
    u_char      *m;
    ngx_pool_t  *p;

    p = pool->current;

    do {
        m = p->d.last;

        if (align) {
            m = ngx_align_ptr(m, NGX_ALIGNMENT);
        }

        if ((size_t) (p->d.end - m) >= size) {//如果在当前内存块有效范围内，进行内存指针的移动
            p->d.last = m + size;

            return m;
        }

        p = p->d.next;//如果当前内存块有效容量不够分配，则移动到下一个内存块进行分配

    } while (p);

    return ngx_palloc_block(pool, size);
}


static void *
ngx_palloc_block(ngx_pool_t *pool, size_t size)
{
    u_char      *m;
    size_t       psize;
    ngx_pool_t  *p, *new;

    psize = (size_t) (pool->d.end - (u_char *) pool);//计算内存池第一个内存块的大小

    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool->log);//分配和第一个内存块同样大小的内存块
    if (m == NULL) {
        return NULL;
    }

    new = (ngx_pool_t *) m;

    new->d.end = m + psize;//设置新内存块的end
    new->d.next = NULL;
    new->d.failed = 0;

    m += sizeof(ngx_pool_data_t);//将指针m移动到d后面的一个位置，作为起始位置
    m = ngx_align_ptr(m, NGX_ALIGNMENT);
    new->d.last = m + size;//设置新内存块的last，即申请使用size大小的内存

    //这里的循环用来找最后一个链表节点，这里failed用来控制循环的长度，如果分配失败次数达到5次，就忽略，不需要每次都从头找起
    for (p = pool->current; p->d.next; p = p->d.next) {
        if (p->d.failed++ > 4) {
            pool->current = p->d.next;
        }
    }

    p->d.next = new;

    return m;
}


static void *
ngx_palloc_large(ngx_pool_t *pool, size_t size)
{
    void              *p;
    ngx_uint_t         n;
    ngx_pool_large_t  *large;

    //直接在系统堆中分配一块空间
    p = ngx_alloc(size, pool->log);
    if (p == NULL) {
        return NULL;
    }

    n = 0;
    //查找到一个空的large区，如果有，则将刚才分配的空间交由它管理
    for (large = pool->large; large; large = large->next) {
        if (large->alloc == NULL) {
            large->alloc = p;
            return p;
        }

        if (n++ > 3) {
            break;
        }
    }

    //为了提高效率， 如果在三次内没有找到空的large结构体，则创建一个
    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);
    if (large == NULL) {
        ngx_free(p);
        return NULL;
    }

    large->alloc = p;
    large->next = pool->large;
    pool->large = large;

    return p;
}


void *
ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment)
{
    void              *p;
    ngx_pool_large_t  *large;

    p = ngx_memalign(alignment, size, pool->log);
    if (p == NULL) {
        return NULL;
    }

    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);
    if (large == NULL) {
        ngx_free(p);
        return NULL;
    }

    large->alloc = p;
    large->next = pool->large;
    pool->large = large;

    return p;
}


ngx_int_t
ngx_pfree(ngx_pool_t *pool, void *p)
{
    ngx_pool_large_t  *l;

    //只检查是否是大内存块，如果是大内存块则释放
    for (l = pool->large; l; l = l->next) {
        if (p == l->alloc) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0,
                           "free: %p", l->alloc);
            ngx_free(l->alloc);
            l->alloc = NULL;

            return NGX_OK;
        }
    }

    return NGX_DECLINED;
}
```
</details>

## 四、开源框架专题

### 1.字符编码和压缩

#### 1.1 字符编码

- ASCII（American Standard Code for Information Interchange），128个字符，用7位二进制表示（00000000-01111111即0x00-0x7F）;EASCII（Extended ASCII），256个字符，用8位二进制表示（00000000-11111111即0x00-0xFF）。当计算机传到了欧洲，国际标准化组织在ASCII的基础上进行了扩展，形成了ISO-8859标准，跟EASCII类似，兼容ASCII，在高128个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，ISO-8859-1、ISO-8859- 2、ISO-8859-3、……、ISO-8859-16。

- 双字节编码可以是变长的，也就是说同一个编码里面有些字符是单字节表示，有些字符是双字节表示。这样做的好处是，一方面可以兼容ASCII，另一方面可以节省存储容量，代价就是会损失一部分码位。

  - GBK（Chinese Internal Code Specification汉字内码扩展规范）是GB2312的扩展（gbk编码能够用来同时表示繁体字和简体字），按理说都属于双字节编码，码位是一样的，根本谈不上扩展，但实际上是预留空间在起作用。
  - UNICODE字符集（国际标准字符集），它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。有多个编码方式，分别是UTF-8，UTF-16，UTF-32编码。

- UTF是Unicode Transformation Format的缩写，意思是“Unicode转换格式”，后面的数字表明**至少**使用多少个比特位（Bit）来存储字符。

  - UFT-8：一种变长的编码方案，使用1~6个字节来存储；

    ![Unicode码表对应utf8编码](https://github.com/gongluck/CVIP/blob/master/images/Unicode码表对应utf8编码.png)

  - UFT-32：一种固定长度的编码方案，不管字符编号大小，直接存储Unicode编号，始终使用4个字节来存储；

  - UTF-16：介于UTF-8和UTF-32之间，使用2个或者4个字节来存储，长度既固定又可变。

    ![Unicode码表对应utf16编码](https://github.com/gongluck/CVIP/blob/master/images/Unicode码表对应utf16编码.png)

  - UTF格式在文件中的**固定文件头**

    ![utf固定文件头](https://github.com/gongluck/CVIP/blob/master/images/utf固定文件头.png)

#### 1.2 libiconv字符编码转换库

- [libiconv例子](https://github.com/gongluck/CVIP/blob/master/code/convert/iconv.c)

  <details>
  <summary>libiconv例子</summary>
  
  ```C
  /*
   * @Author: gongluck 
   * @Date: 2020-11-18 07:52:34 
   * @Last Modified by: gongluck
   * @Last Modified time: 2020-11-18 09:14:11
   */
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <iconv.h>
  
  int main()
  {
      iconv_t cd = iconv_open("GBK", "UTF-8"); //UTF8 -> GBK
      if (cd == (iconv_t)-1)
      {
          printf("iconv_open failed.\n");
          exit(-1);
      }
  
      char str[] = "iconv例子";
      char *pstr = str;
      size_t len = sizeof(str);
      char out[100] = {0};
      char *pout = out;
      size_t leftlen = sizeof(out);
      while (pstr-str < sizeof(str))
      {
          pout = out;
          leftlen = sizeof(out);
          int n = iconv(cd, &pstr, &len, &pout, &leftlen);
          //printf("iconv return %d\n", n);
          if (pout != out)//有转换成功字符
          {
              printf("%.*s", (int)(sizeof(out)-leftlen), out);
          }
          else
          {
              break;
          }
          
          if(n != -1)
          {
              pout = out;
  			leftlen = sizeof(out);
  			n = iconv(cd, NULL, NULL, &pout, &leftlen);
  			if (pout != out) // 检测iconv内部是否还有缓存
  			{
  				printf("%.*s", (int)(sizeof(out)-leftlen), out);
  			}
  			break;
          }
      }
      printf("\n");
      iconv_close(cd);
  
      return 0;
  }
  ```
  </details>

#### 1.3 zlib

- 编译安装zlib

  ```shell
  #下载
  wget http://www.zlib.net/zlib-1.2.11.tar.gz
  #解压
  tar -zxvf zlib-1.2.11.tar.gz
  #进入目录
  cd zlib-1.2.11
  #配置
  ./configure
  #编译
  make -j 8
  #检查
  make check
  #安装
  sudo make install
  ```

- [zlib例子](https://github.com/gongluck/CVIP/blob/master/code/zlib/zlib.c)

  <details>
  <summary>zlib例子</summary>
  
  ```C
  /*
   * @Author: gongluck 
   * @Date: 2020-11-18 17:02:24 
   * @Last Modified by: gongluck
   * @Last Modified time: 2020-11-18 17:05:37
   */
  
  // gcc zlib.c -lz
  // ./a.out < zlib.c > out
  // ./a.out -d < out > zlib.c
  
  #include <stdio.h>
  #include <string.h>
  #include <assert.h>
  #include "zlib.h"
  
  #if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
  #include <fcntl.h>
  #include <io.h>
  #define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
  #else
  #define SET_BINARY_MODE(file)
  #endif
  
  #define CHUNK 1024
  
  /* Compress from file source to file dest until EOF on source.
     def() returns Z_OK on success, Z_MEM_ERROR if memory could not be
     allocated for processing, Z_STREAM_ERROR if an invalid compression
     level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
     version of the library linked do not match, or Z_ERRNO if there is
     an error reading or writing the files. */
  int def(FILE *source, FILE *dest, int level)
  {
      int ret, flush;
      unsigned have;
      z_stream strm;
      unsigned char in[CHUNK];
      unsigned char out[CHUNK];
  
      /* allocate deflate state */
      strm.zalloc = Z_NULL;
      strm.zfree = Z_NULL;
      strm.opaque = Z_NULL;
      ret = deflateInit(&strm, level);
      if (ret != Z_OK)
          return ret;
  
      /* compress until end of file */
      do
      {
          strm.avail_in = fread(in, 1, CHUNK, source);
          if (ferror(source))
          {
              (void)deflateEnd(&strm);
              return Z_ERRNO;
          }
          flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;
          strm.next_in = in;
  
          /* run deflate() on input until output buffer not full, finish
             compression if all of source has been read in */
          do
          {
              strm.avail_out = CHUNK;
              strm.next_out = out;
              ret = deflate(&strm, flush);   /* no bad return value */
              assert(ret != Z_STREAM_ERROR); /* state not clobbered */
              have = CHUNK - strm.avail_out;
              if (fwrite(out, 1, have, dest) != have || ferror(dest))
              {
                  (void)deflateEnd(&strm);
                  return Z_ERRNO;
              }
          } while (strm.avail_out == 0);
          assert(strm.avail_in == 0); /* all input will be used */
  
          /* done when last data in file processed */
      } while (flush != Z_FINISH);
      assert(ret == Z_STREAM_END); /* stream will be complete */
  
      /* clean up and return */
      (void)deflateEnd(&strm);
      return Z_OK;
  }
  
  /* Decompress from file source to file dest until stream ends or EOF.
     inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be
     allocated for processing, Z_DATA_ERROR if the deflate data is
     invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and
     the version of the library linked do not match, or Z_ERRNO if there
     is an error reading or writing the files. */
  int inf(FILE *source, FILE *dest)
  {
      int ret;
      unsigned have;
      z_stream strm;
      unsigned char in[CHUNK];
      unsigned char out[CHUNK];
  
      /* allocate inflate state */
      strm.zalloc = Z_NULL;
      strm.zfree = Z_NULL;
      strm.opaque = Z_NULL;
      strm.avail_in = 0;
      strm.next_in = Z_NULL;
      ret = inflateInit(&strm);
      if (ret != Z_OK)
          return ret;
  
      /* decompress until deflate stream ends or end of file */
      do
      {
          strm.avail_in = fread(in, 1, CHUNK, source);
          if (ferror(source))
          {
              (void)inflateEnd(&strm);
              return Z_ERRNO;
          }
          if (strm.avail_in == 0)
              break;
          strm.next_in = in;
  
          /* run inflate() on input until output buffer not full */
          do
          {
              strm.avail_out = CHUNK;
              strm.next_out = out;
              ret = inflate(&strm, Z_NO_FLUSH);
              assert(ret != Z_STREAM_ERROR); /* state not clobbered */
              switch (ret)
              {
              case Z_NEED_DICT:
                  ret = Z_DATA_ERROR; /* and fall through */
              case Z_DATA_ERROR:
              case Z_MEM_ERROR:
                  (void)inflateEnd(&strm);
                  return ret;
              }
              have = CHUNK - strm.avail_out;
              if (fwrite(out, 1, have, dest) != have || ferror(dest))
              {
                  (void)inflateEnd(&strm);
                  return Z_ERRNO;
              }
          } while (strm.avail_out == 0);
  
          /* done when inflate() says it's done */
      } while (ret != Z_STREAM_END);
  
      /* clean up and return */
      (void)inflateEnd(&strm);
      return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;
  }
  
  /* report a zlib or i/o error */
  void zerr(int ret)
  {
      fputs("zpipe: ", stderr);
      switch (ret)
      {
      case Z_ERRNO:
          if (ferror(stdin))
              fputs("error reading stdin\n", stderr);
          if (ferror(stdout))
              fputs("error writing stdout\n", stderr);
          break;
      case Z_STREAM_ERROR:
          fputs("invalid compression level\n", stderr);
          break;
      case Z_DATA_ERROR:
          fputs("invalid or incomplete deflate data\n", stderr);
          break;
      case Z_MEM_ERROR:
          fputs("out of memory\n", stderr);
          break;
      case Z_VERSION_ERROR:
          fputs("zlib version mismatch!\n", stderr);
      }
  }
  
  /* compress or decompress from stdin to stdout */
  int main(int argc, char **argv)
  {
      int ret;
  
      /* avoid end-of-line conversions */
      SET_BINARY_MODE(stdin);
      SET_BINARY_MODE(stdout);
  
      /* do compression if no arguments */
      if (argc == 1)
      {
          ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);
          if (ret != Z_OK)
              zerr(ret);
          return ret;
      }
  
      /* do decompression if -d specified */
      else if (argc == 2 && strcmp(argv[1], "-d") == 0)
      {
          ret = inf(stdin, stdout);
          if (ret != Z_OK)
              zerr(ret);
          return ret;
      }
  
      /* otherwise, report usage */
      else
      {
          fputs("zpipe usage: zpipe [-d] < source > dest\n", stderr);
          return 1;
      }
  }
  ```
  </details>

  

### 2.Json和Xml

#### 2.1 cJSON

- [cJSON例子](https://github.com/gongluck/CVIP/blob/master/code/json/cjson/test.c)

  <details>
  <summary>[cJSON例子](https://github.com/gongluck/CVIP/blob/master/code/json/cjson/test.c)</summary>

  ```C
  /*
   * @Author: gongluck 
   * @Date: 2020-11-18 21:27:47 
   * @Last Modified by: gongluck
   * @Last Modified time: 2020-11-18 21:41:36
   */

  // gcc *.c -lm

  #include <stdio.h>
  #include "cJSON.h"

  int main()
  {
      cJSON* root = cJSON_CreateObject();
      cJSON_AddBoolToObject(root, "bool", cJSON_False);
      cJSON_AddStringToObject(root, "str", "cJSON");
  
      char* str = cJSON_Print(root);
      printf("%s\n", str);
      cJSON_Delete(root);
      root = NULL;

      root = cJSON_Parse(str);
      cJSON* b = cJSON_GetObjectItem(root, "bool");
      if(b->type == cJSON_True || b->type == cJSON_False)
          printf("bool value : %d\n", b->type);
      cJSON* s = cJSON_GetObjectItem(root, "str");
      if(s->type == cJSON_String)
          printf("str value : %s\n", s->valuestring);
      cJSON_Delete(root);
      return 0;
  }
  ```
  </details>

#### 2.2 jsoncpp

- 编译安装

  ```shell
  # 下载
  git clone https://github.com/open-source-parsers/jsoncpp.git
  cd jsoncpp
  mkdir -p build/release
  cd build/release
  # 编译
  cmake -DCMAKE_BUILD_TYPE=release -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_INCLUDEDIR=include/jsoncpp -DARCHIVE_INSTALL_DIR=. -G "Unix Makefiles" ../..
  make
  # 安装
  sudo make install
  ```

- [jsoncpp例子](https://github.com/gongluck/CVIP/blob/master/code/json/jsoncpp/test.cpp)

  <details>
  <summary>[jsoncpp例子](https://github.com/gongluck/CVIP/blob/master/code/json/cjson/test.c)</summary>
  
  ```C++
  /*
   * @Author: gongluck 
   * @Date: 2020-11-19 09:40:21 
   * @Last Modified by: gongluck
   * @Last Modified time: 2020-11-19 09:46:42
   */
  
  // g++ test.cpp -ljsoncpp
  
  #include <iostream>
  #include <string>
  #include <jsoncpp/json/json.h>
  
  void readJson()
  {
      std::string strValue = "{\"name\":\"json\",\"array\":[{\"cpp\":\"jsoncpp\"},{\"java\":\"jsoninjava\"},{\"php\":\"support\"}]}";
  
      Json::Reader reader;
      Json::Value value;
  
      if (reader.parse(strValue, value))
      {
          std::string out = value["name"].asString();
          std::cout << out << std::endl;
          const Json::Value arrayObj = value["array"];
          for (unsigned int i = 0; i < arrayObj.size(); i++)
          {
              if (!arrayObj[i].isMember("cpp"))
                  continue;
              out = arrayObj[i]["cpp"].asString();
              std::cout << out;
              if (i != (arrayObj.size() - 1))
                  std::cout << std::endl;
          }
      }
  }
  
  void writeJson()
  {
      Json::Value root;
      Json::Value arrayObj;
      Json::Value item;
  
      item["cpp"] = "jsoncpp";
      item["java"] = "jsoninjava";
      item["php"] = "support";
      arrayObj.append(item);
  
      root["name"] = "json";
      root["array"] = arrayObj;
  
      root.toStyledString();
      std::string out = root.toStyledString();
      std::cout << out << std::endl;
  }
  
  int main(int argc, char **argv)
  {
      readJson();
      writeJson();
      return 0;
  }
  ```
  </details>
  

#### 2.3 TinyXML2

- 安装编译

  ```shell
  #下载 tinyxml2
  git clone https://github.com/leethomason/tinyxml2.git
  #进入相应目录并编译
  cd tinyxml2/
  cmake . 
  make -j 8
  #测试该版本的准确性
  ./xmltest
  #安装
  sudo make install
  ```

- [tinyxml2例子](https://github.com/gongluck/CVIP/blob/master/code/xml/tinyxml2/test.cpp)

  <details>
  <summary>[tinyxml2例子](https://github.com/gongluck/CVIP/blob/master/code/json/cjson/test.c)</summary>
  
  ```C++
  /*
   * @Author: gongluck 
   * @Date: 2020-11-19 17:11:24 
   * @Last Modified by: gongluck
   * @Last Modified time: 2020-11-19 17:27:23
   */
  
  // g++ test.cpp -ltinyxml2
  
  #include <iostream>
  #include "tinyxml2.h"
  
  int main(void)
  {
      const char *xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>   \
                          <note>                      \
                              <to>beijing</to>             \
                              <from>shenzhen</from>           \
                              <heading>Reminder</heading> \
                              <body>Don't forget the meeting!</body> \
                          </note>";
      tinyxml2::XMLDocument doc;
      doc.Parse(xml);
      std::cout << doc.ErrorID() << std::endl;
  
      // 1. 第一种刷新到本地
      FILE *fp = fopen("memory_1.xml", "wb");
      tinyxml2::XMLPrinter printer(fp);
      doc.Print(&printer); // 打印到文件
      fclose(fp);
  
      // 2. 第二种刷新到本地
      doc.SaveFile("memory_2.xml");
  
      return 0;
  }
  ```
  </details>
  

### 3.ProtoBuf

#### 3.1 序列化和反序列化

- 序列化：把对象转换为字节序列的过程称为对象。

  ![常用序列化协议比较](https://github.com/gongluck/CVIP/blob/master/images/常用序列化协议比较.png)

  - TLV编码及其变体（tag, length和value的缩写）：比如Protobuf。
  - 文本流编码：比如XML/JSON。
  - 固定结构编码：基本原理是，协议约定了传输字段类型和字段含义，和TLV的方式类似，但是没有了tag和len，只有value，比如TCP/IP。
  - 内存dump：把内存中的数据直接输出，不做任何序列化操作。反序列化的时候，直接还原内存。

- 反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

#### 3.2 编译安装ProtoBuf

```shell
#下载源码
wget https://github.com/protocolbuffers/protobuf/archive/v3.1.0.tar.gz
tar -zxvf v3.1.0.tar.gz
cd protobuf-3.1.0/
#编译
./autogen.sh
./configure
make -j 8
make check
sudo make install
# refresh shared library cache.
sudo ldconfig
```

#### 3.3 [ProtoBuf例子](https://github.com/gongluck/CVIP/blob/master/code/protobuf)

```protobuf
/*
 * @Author: gongluck 
 * @Date: 2020-11-20 18:16:05 
 * @Last Modified by:   gongluck 
 * @Last Modified time: 2020-11-20 18:16:05 
 */
 
// protoc --cpp_out=./ addressbook.proto

syntax = "proto3";

package Test;

message Person
{
    string name = 1;
    int32 id = 2;
    string email = 3;

    enum PhoneType
    {
        MOBLIE = 0;//首成员必须为0
        HOME = 1;
        WORK = 2;
    }
    message PhoneNumber
    {
        string number = 1;
        PhoneType type = 2;
    }
    repeated PhoneNumber phones = 4;
}

message AddressBook
{
    repeated Person people = 1;
}
```

<details>
<summary>ProtoBuf例子</summary>

```C++
/*
 * @Author: gongluck 
 * @Date: 2020-11-20 17:23:22 
 * @Last Modified by: gongluck
 * @Last Modified time: 2020-11-20 18:14:44
 */

// g++ *.cc *.cpp `pkg-config --cflags --libs protobuf`

#include <iostream>
#include "addressbook.pb.h"

using namespace std;

int main()
{
    char buf[1024];
    int len;

    GOOGLE_PROTOBUF_VERIFY_VERSION;

    Test::Person obj;
    obj.set_name("gongluck");
    obj.set_id(1);
    *obj.mutable_email() = "https://github.com.cnpmjs.org/gongluck/CVIP";
    len = obj.ByteSize();
    cout << "len = " << len << endl;
    obj.SerializeToArray(buf, len);

    Test::Person obj2;
    obj2.ParseFromArray(buf, len);
    cout << "name = " << obj2.name() << endl;
    cout << "id = " << obj2.id() << endl;
    cout << "email = " << obj2.email() << endl;

    google::protobuf::ShutdownProtobufLibrary();

    return 0;
}
```
</details>

### 4.消息队列

#### 4.1 消息队列比较

![消息队列比较](https://github.com/gongluck/CVIP/blob/master/images/消息队列比较.png)

#### 4.2 zmq编译安装

```shell
#安装编译依赖
sudo apt-get install libtool pkg-config build-essential autoconf automake
#安装加密库
git clone git://github.com/jedisct1/libsodium.git
cd libsodium
./autogen.sh -s
./configure && make -j 8 && make check
sudo make install
sudo ldconfig
cd ..
#下载
git clone https://github.com/zeromq/libzmq.git
cd libzmq
#查看tag
#git tag
#版本 获取指定的版本
git checkout v4.3.2
./autogen.sh
./configure && make -j 8 && make check
sudo make install
sudo ldconfig
cd ..
```

#### 4.3 [zmq例子](https://github.com/gongluck/CVIP/blob/master/code/messagequeue/zmq)

- [服务端](https://github.com/gongluck/CVIP/blob/master/code/messagequeue/zmq/zmqserver.c)

  <details>
  <summary>服务端代码</summary>
  
  ```C
  /*
   * @Author: gongluck 
   * @Date: 2020-11-24 09:49:11 
   * @Last Modified by: gongluck
   * @Last Modified time: 2020-11-24 09:51:26
   */
  
  // gcc zmqserver.c -lzmq
  
  #include <zmq.h>
  #include <stdio.h>
  #include <unistd.h>
  #include <string.h>
  #include <assert.h>
  
  int main(void)
  {
      // Socket to talk to clients
      void *context = zmq_ctx_new();
      // 与客户端通信的套接字
      void *responder = zmq_socket(context, ZMQ_REP);
      int rc = zmq_bind(responder, "tcp://*:5555");
      assert(rc == 0);
  
      while (1)
      {
          // 等待客户端请求
          char buffer[10];
          zmq_recv(responder, buffer, 10, 0);
          printf("收到 %.*s\n", 10, buffer);
          // 返回应答
          zmq_send(responder, "RECVED", 6, 0);
      }
      return 0;
  }
  ```
  </details>

- [客户端](https://github.com/gongluck/CVIP/blob/master/code/messagequeue/zmq/zmqclient.c)

  <details>
  <summary>客户端代码</summary>
  
  ```C
  /*
   * @Author: gongluck 
   * @Date: 2020-11-24 09:52:58 
   * @Last Modified by: gongluck
   * @Last Modified time: 2020-11-24 09:56:14
   */
  
  //gcc zmqclient.c -lzmq
  
  #include <zmq.h>
  #include <string.h>
  #include <stdio.h>
  #include <unistd.h>
  
  int main(void)
  {
      printf("Connecting to zmq server...\n");
      void *context = zmq_ctx_new();
      // 连接⾄服务端的套接字
      void *requester = zmq_socket(context, ZMQ_REQ);
      zmq_connect(requester, "tcp://localhost:5555");
  
      char buffer[10];
      for (int request_nbr = 0; request_nbr != 10; request_nbr++)
      {  
          printf("正在发送 %d...\n", request_nbr);
          zmq_send(requester, "Hello", 5, 0);
          zmq_recv(requester, buffer, 10, 0);
          printf("接收到 %.*s\n", 10, buffer);
      }
      zmq_close(requester);
      zmq_ctx_destroy(context);
      return 0;
  }
  ```
  </details>

### 5.OpenSSL

#### 5.1 OpenSSL编译安装

```shell
wget https://www.openssl.org/source/old/1.1.0/openssl-1.1.0l.tar.gz
tar xzvf OpenSSL-1.1.0l.tar.gz
cd OpenSSL-1.1.0l
./config --prefix=/usr/local/OpenSSL
make -j 8
sudo make install
```

#### 5.2 [OpenSSL例子](https://github.com/gongluck/CVIP/blob/master/code/openssl/test.c)

<details>
<summary>OpenSSL例子</summary>

```C
/*
 * @Author: gongluck 
 * @Date: 2020-11-24 18:44:16 
 * @Last Modified by: gongluck
 * @Last Modified time: 2020-11-24 18:53:20
 */

// gcc test.c -lssl -lcrypto

#include <stdio.h>
#include <string.h>
#include <openssl/lhash.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/sha.h>
#include <openssl/rsa.h>

#define NAME_LENGTH 32

typedef struct _Person
{
    char name[NAME_LENGTH];
    int high;
    char otherInfo[NAME_LENGTH];
} Person;

// 自定义比较函数
static int person_cmp(const void *a, const void *b)
{
    char *namea = ((Person *)a)->name;
    char *nameb = ((Person *)b)->name;
    return strcmp(namea, nameb);
}

void print_value(void *a)
{
    Person *p = (Person *)a;
    printf("name: %s\n", p->name);
    printf("high: %d\n", p->high);
    printf("other info : %s\n", p->otherInfo);
}

int main()
{
    // hash
    OPENSSL_LHASH *h = lh_new(NULL, person_cmp);
    if (h == NULL)
    {
        printf("err.\n");
        return -1;
    }

    Person p1 = {"gongluck", 170, "xxxx"};
    Person p2 = {"ben", 175, "xxxx"};
    Person p3 = {"ken", 170, "xxxx"};
    Person p4 = {"dio", 170, "xxxx"};

    lh_insert(h, &p1);
    lh_insert(h, &p2);
    lh_insert(h, &p3);
    lh_insert(h, &p4);

    lh_doall(h, print_value);

    void *data = lh_retrieve(h, (const char *)"dio"); //person_cmp return 0
    if (data == NULL)
    {
        return -1;
    }

    print_value(data);
    lh_free(h);

    printf("\n------------------------------\n");

    //bio
    BIO *b = BIO_new(BIO_s_mem());
    int len = BIO_write(b, "OpenSSL", 4);
    len = BIO_printf(b, "%s", "gongluck");
    printf("len: %d\n", len);
    char *out = OPENSSL_malloc(len);
    len = BIO_read(b, out, len);
    printf("%s, len: %d\n", out, len);
    OPENSSL_free(out);
    BIO_free(b);

    printf("\nsocket bio\n");
    int sock = BIO_get_accept_socket("8899", 0);
    BIO *bsock = BIO_new_socket(sock, BIO_NOCLOSE);
    char *addr = NULL;
    int ret = BIO_accept(sock, &addr);
    BIO_set_fd(bsock, ret, BIO_NOCLOSE);
    while (1)
    {
        char out[128] = {0};
        BIO_read(bsock, out, 128);
        if (out[0] = 'q')
            break;
        printf("%s\n", out);
    }
    BIO_free(bsock);

    printf("\n------------------------------\n");

    //base64
    unsigned char in[30], base64[40], decode[30];
    EVP_ENCODE_CTX *ectx = EVP_ENCODE_CTX_new();
    EVP_EncodeInit(ectx);
    for (int i = 0; i < 30; i++)
    {
        in[i] = i;
    }
    int outl, inl = 30;
    EVP_EncodeUpdate(ectx, base64, &outl, in, inl);
    EVP_EncodeFinal(ectx, base64 + outl, &outl);
    EVP_ENCODE_CTX_free(ectx);
    printf("%40s\n", base64);

    printf("\n------------------------------\n");

    //rsa
    unsigned char inbuf[] = "https://github.com/gongluck/CVIP";
    unsigned char outbuf[128] = {0};
    int n = strlen(in);
    MD4(inbuf, n, outbuf);
    printf("MD4 result: \n"); // 16 byte
    for (int i = 0; i < 16; i++)
    {
        printf("%x", outbuf[i]);
    }
    printf("\n");
    MD5(inbuf, n, outbuf);
    printf("MD5 result: \n"); // 16 byte
    for (int i = 0; i < 16; i++)
    {
        printf("%x", outbuf[i]);
    }
    printf("\n");
    // SHA(inbuf, n, outbuf);
    // printf("SHA result: \n"); // 20 byte
    // for (int i = 0; i < 20; i++)
    // {
    //     printf("%x", outbuf[i]);
    // }
    // printf("\n");
    SHA1(inbuf, n, outbuf);
    printf("SHA1 result: \n"); // 20 byte
    for (int i = 0; i < 20; i++)
    {
        printf("%x", outbuf[i]);
    }
    printf("\n");
    SHA256(inbuf, n, outbuf);
    printf("SHA256 result: \n"); // 32 byte
    for (int i = 0; i < 32; i++)
    {
        printf("%x", outbuf[i]);
    }
    printf("\n");
    SHA512(inbuf, n, outbuf);
    printf("SHA512 result: \n"); // 64 byte
    for (int i = 0; i < 64; i++)
    {
        printf("%x", outbuf[i]);
    }
    printf("\n");

    return 0;
}
```
</details>

### 6.网络IO管理

#### 6.1 [信号驱动IO](https://github.com/gongluck/CVIP/blob/master/code/io/signalio.c)

<details>
<summary>信号驱动IO</summary>

```C
/*
 * @Author: gongluck 
 * @Date: 2020-11-26 08:05:17 
 * @Last Modified by: gongluck
 * @Last Modified time: 2020-11-26 08:19:07
 */

// test : nc -uv 127.0.0.1 9096

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>

int sockfd = 0;

void do_sigio(int sig)
{
    struct sockaddr_in cli_addr;
    int clilen = sizeof(struct sockaddr_in);

    char buffer[256] = {0};
    int len = recvfrom(sockfd, buffer, 256, 0, (struct sockaddr *)&cli_addr, (socklen_t *)&clilen);
    printf("Message : %s\r\n", buffer);
    int slen = sendto(sockfd, buffer, len, 0, (struct sockaddr *)&cli_addr, clilen);
}

int main(int argc, char *argv[])
{
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    struct sigaction sigio_action;
    sigio_action.sa_flags = 0;
    sigio_action.sa_handler = do_sigio;
    sigaction(SIGIO, &sigio_action, NULL);//SIGIO call do_sigio

    struct sockaddr_in serv_addr = {0};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9096);
    serv_addr.sin_addr.s_addr = INADDR_ANY;

    fcntl(sockfd, F_SETOWN, getpid());
    int flags = fcntl(sockfd, F_GETFL, 0);
    flags |= O_ASYNC | O_NONBLOCK;//异步非阻塞
    fcntl(sockfd, F_SETFL, flags);

    bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    while (1)
        sleep(1);

    close(sockfd);

    return 0;
}
```
</details>

#### 6.2 [select IO](https://github.com/gongluck/CVIP/blob/master/code/io/select.c)

<details>
<summary>select IO</summary>

```C
/*
 * @Author: gongluck 
 * @Date: 2020-11-26 08:36:17 
 * @Last Modified by: gongluck
 * @Last Modified time: 2020-11-26 08:39:02
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <netinet/tcp.h>
#include <arpa/inet.h>

#include <errno.h>
#include <fcntl.h>

#define BUFFER_LENGTH 1024

int main(int argc, char *argv[])
{
    int port = 9096;
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd < 0)
    {
        perror("socket");
        return -1;
    }

    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(listenfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) < 0)
    {
        perror("bind");
        return -2;
    }
    if (listen(listenfd, 5) < 0)
    {
        perror("listen");
        return -3;
    }

    fd_set rfds, rset;
    FD_ZERO(&rfds);
    FD_SET(listenfd, &rfds);

    int max_fd = listenfd;
    int i = 0;

    while (1)
    {
        rset = rfds;
        int nready = select(max_fd + 1, &rset, NULL, NULL, NULL);
        if (nready < 0)
        {
            printf("select error : %d\n", errno);
            continue;
        }

        if (FD_ISSET(listenfd, &rset)) // listen的fd可读代表有连接到达
        {
            struct sockaddr_in client_addr = {0};
            socklen_t client_len = sizeof(client_addr);

            int clientfd = accept(listenfd, (struct sockaddr *)&client_addr, &client_len);
            if (clientfd <= 0)
                continue;

            char str[INET_ADDRSTRLEN] = {0};
            printf("recvived from %s at port %d, listenfd:%d, clientfd:%d\n", inet_ntop(AF_INET, &client_addr.sin_addr, str, sizeof(str)),
                   ntohs(client_addr.sin_port), listenfd, clientfd);

            if (max_fd == FD_SETSIZE) // select的fd上限一般是1024
            {
                printf("clientfd --> out range\n");
                break;
            }
            FD_SET(clientfd, &rfds); // 将新连接fd加入到读取队列中

            if (clientfd > max_fd)
                max_fd = clientfd;

            printf("listenfd:%d, max_fd:%d, clientfd:%d\n", listenfd, max_fd, clientfd);

            if (--nready == 0)
                continue;
        }

        for (i = listenfd + 1; i <= max_fd; i++)
        {
            if (FD_ISSET(i, &rset))
            {
                char buffer[BUFFER_LENGTH] = {0};
                int ret = recv(i, buffer, BUFFER_LENGTH, 0);
                if (ret < 0)
                {
                    if (errno == EAGAIN || errno == EWOULDBLOCK) // 实际可能出现被其他线程读取掉数据的情况
                    {
                        printf("read all data");
                    }
                    FD_CLR(i, &rfds);
                    close(i);
                }
                else if (ret == 0)
                {
                    printf("disconnect %d\n", i);
                    FD_CLR(i, &rfds);
                    close(i);
                    break;
                }
                else
                {
                    printf("Recv: %s, %d Bytes\n", buffer, ret);
                }
                if (--nready == 0)
                    break;
            }
        }
    }

    return 0;
}
```
</details>

#### 6.3 [poll IO](https://github.com/gongluck/CVIP/blob/master/code/io/poll.c)

<details>
<summary>poll IO</summary>

```C
/*
 * @Author: gongluck 
 * @Date: 2020-11-26 08:36:17 
 * @Last Modified by: gongluck
 * @Last Modified time: 2020-11-26 08:44:12
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <sys/poll.h>

#include <errno.h>
#include <fcntl.h>

#define BUFFER_LENGTH 1024
#define POLL_SIZE 1024

int main(int argc, char *argv[])
{
    int port = 9096;
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd < 0)
    {
        perror("socket");
        return -1;
    }

    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(listenfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) < 0)
    {
        perror("bind");
        return -2;
    }
    if (listen(listenfd, 5) < 0)
    {
        perror("listen");
        return -3;
    }

    struct pollfd fds[POLL_SIZE] = {0};
    fds[0].fd = listenfd;
    fds[0].events = POLLIN;

    int max_fd = 0, i = 0;
    for (i = 1; i < POLL_SIZE; i++)
    {
        fds[i].fd = -1;
    }

    while (1)
    {
        int nready = poll(fds, max_fd + 1, 5);
        if (nready <= 0)
            continue;

        if ((fds[0].revents & POLLIN) == POLLIN) // 判断listenfd是否有数据可读(新连接)
        {
            struct sockaddr_in client_addr = {0};
            socklen_t client_len = sizeof(client_addr);

            int clientfd = accept(listenfd, (struct sockaddr *)&client_addr, &client_len);
            if (clientfd <= 0)
                continue;

            char str[INET_ADDRSTRLEN] = {0};
            printf("recvived from %s at port %d, sockfd:%d, clientfd:%d\n", inet_ntop(AF_INET, &client_addr.sin_addr, str, sizeof(str)),
                   ntohs(client_addr.sin_port), listenfd, clientfd);

            fds[clientfd].fd = clientfd;
            fds[clientfd].events = POLLIN;

            if (clientfd > max_fd)
                max_fd = clientfd;

            if (--nready == 0)
                continue;
        }

        for (i = listenfd + 1; i <= max_fd; i++)
        {
            if (fds[i].revents & (POLLIN | POLLERR))
            {
                char buffer[BUFFER_LENGTH] = {0};
                int ret = recv(i, buffer, BUFFER_LENGTH, 0);
                if (ret < 0)
                {
                    if (errno == EAGAIN || errno == EWOULDBLOCK)
                    {
                        printf("read all data");
                    }

                    close(i);
                    fds[i].fd = -1;
                }
                else if (ret == 0)
                {
                    printf(" disconnect %d\n", i);

                    close(i);
                    fds[i].fd = -1;
                    break;
                }
                else
                {
                    printf("Recv: %s, %d Bytes\n", buffer, ret);
                }
                if (--nready == 0)
                    break;
            }
        }
    }

    return 0;
}
```
</details>

#### 6.4 [epoll IO](https://github.com/gongluck/CVIP/blob/master/code/io/epoll.c)

<details>
<summary>epoll IO</summary>

```C
/*
 * @Author: gongluck 
 * @Date: 2020-11-26 08:36:17 
 * @Last Modified by: gongluck
 * @Last Modified time: 2020-11-26 08:52:01
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#include <errno.h>
#include <fcntl.h>

#define BUFFER_LENGTH 1024
#define EPOLL_SIZE 1024

int main(int argc, char *argv[])
{
    int port = 9096;
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd < 0)
    {
        perror("socket");
        return -1;
    }

    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(listenfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) < 0)
    {
        perror("bind");
        return -2;
    }
    if (listen(listenfd, 5) < 0)
    {
        perror("listen");
        return -3;
    }

    int epoll_fd = epoll_create(EPOLL_SIZE);
    struct epoll_event ev, events[EPOLL_SIZE] = {0};

    ev.events = EPOLLIN;
    ev.data.fd = listenfd;
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listenfd, &ev);

    while (1)
    {
        int nready = epoll_wait(epoll_fd, events, EPOLL_SIZE, -1);
        if (nready == -1)
        {
            printf("epoll_wait\n");
            break;
        }

        for (int i = 0; i < nready; i++)
        {
            if (events[i].data.fd == listenfd)
            {
                struct sockaddr_in client_addr = {0};
                socklen_t client_len = sizeof(client_addr);

                int clientfd = accept(listenfd, (struct sockaddr *)&client_addr, &client_len);
                if (clientfd <= 0)
                    continue;

                char str[INET_ADDRSTRLEN] = {0};
                printf("recvived from %s at port %d, sockfd:%d, clientfd:%d\n", inet_ntop(AF_INET, &client_addr.sin_addr, str, sizeof(str)),
                       ntohs(client_addr.sin_port), listenfd, clientfd);

                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = clientfd;
                epoll_ctl(epoll_fd, EPOLL_CTL_ADD, clientfd, &ev);
            }
            else
            {
                int clientfd = events[i].data.fd;

                char buffer[BUFFER_LENGTH] = {0};
                int ret = recv(clientfd, buffer, BUFFER_LENGTH, 0);
                if (ret < 0)
                {
                    if (errno == EAGAIN || errno == EWOULDBLOCK)
                    {
                        printf("read all data");
                    }

                    close(clientfd);

                    ev.events = EPOLLIN | EPOLLET;
                    ev.data.fd = clientfd;
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, clientfd, &ev);
                }
                else if (ret == 0)
                {
                    printf(" disconnect %d\n", clientfd);

                    close(clientfd);

                    ev.events = EPOLLIN | EPOLLET;
                    ev.data.fd = clientfd;
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, clientfd, &ev);

                    break;
                }
                else
                {
                    printf("Recv: %s, %d Bytes\n", buffer, ret);
                }
            }
        }
    }

    return 0;
}
```
</details>
